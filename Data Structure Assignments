Q.1 Create a structure Student ( rollno, name), Create a structure variable and Access the members using structure variable.

Ans. #include<stdio.h>
     #include<conio.h>

struct student
{
	int rollno;
	char name[20];
};

int main()
{
	struct student s1;
	
	s1.rollno=7;
	strcpy(s1.name,"vishal munde");
	
	printf("roll no : %d , name : %s", s1.rollno,s1.name);
}
====================================================================================================================================

Q.2 Create a structure pointer which can access the members of the structure Student and print member values.

Ans. #include<stdio.h>

struct student
{
	int rollno;
	char name[30];
};

int main()
{
	struct student *s1,s;
	s1=&s;
	s1->rollno=21;
	strcpy(s1->name,"vishal");
	
	printf("roll no : , %d , name : %s",s1->rollno,s1->name);
	
}
=======================================================================================================================================

Q.3 Create an array of structure which is used to store 3 employee records.

Ans. #include<stdio.h>
     #include<conio.h>

struct employee
{
	int id;
	char name[30];
	char city[30];
};

int main()
{
	struct employee e[7];
	char nm[25];
	char cy[20];
	int i;
	for(i=0;i<3;i++)
	{
		printf("enter id : ");
		scanf("%d",&e[i].id);
		
		fflush(stdin);
		printf("enter name : ");
		gets(nm);
		strcpy(e[i].name,nm);
		
		fflush(stdin);
		printf("enter city : ");
		gets(cy);
		strcpy(e[i].city,cy);
		fflush(stdin);
	}
	
	for(i=0;i<3;i++)
	{
		printf("id : %d , name : %s , city : %s\n",e[i].id,e[i].name,e[i].city);
	}
}
==============================================================================================================================

Q.4 Create a float pointer which points to the float array and access all elements of array using float pointer.

Ans. #include<stdio.h>

int main()
{
	float num[]={1.2,2.3,3.4,};
	float *p=num;
	
	int i;
	for(i=0;i<3;i++)
	{
		printf("%f\t",*(p+i));
	}
}
===============================================================================================================================

Q.5 Create an integer pointer for which memroy is allocated dynamically.

Ans. #include<stdio.h>

int main()
{
	int *p;
	
	p=(int*)malloc(sizeof(int));
	
	*p=100;
	
	printf("value : %d",*p);
}
===================================================================================================================================

Q.6 Create a stack of 5 characters and display all elements.

Ans. #include<stdio.h>
     #include<stdlib.h>
#define SIZE 7

typedef struct st
{
	int top;
	char elements[SIZE];
}stack;

void initialize(stack *sp)
{
	sp->top=-1;
}

void push(stack *sp,int item)
{
	if(is_full(sp))
	printf("\nstack overflow");
	
	else 
	sp->elements[++sp->top]=item;
}

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
	printf("\nstack underflow");
	
	else
	x=sp->elements[sp->top--];
	
	return x;
}

int is_full(stack *sp)
{
	if(sp->top==SIZE-1)
	return 1;
	
	else
	return 0;
}

int is_empty(stack *sp)
{
	if(sp->top== -1)
	return 1;
	
	else
	return 0;
}

int main()
{
	stack s1;
	
	push(&s1,'v');
	push(&s1,'i');
	push(&s1,'s');
	push(&s1,'h');
	push(&s1,'a');
	push(&s1,'l');
	
	int i;
	
	for(i=s1.top;i!=-1;i--)
	{
		printf("%c",s1.elements[i]);
	}
	
	
}
===================================================================================================================

Q.7 Create a stack of 5 names of employees and delete the last name and display it.

Ans. #include<stdio.h>
     #include<stdlib.h>
#define SIZE 10
typedef struct st
{
    int top;
    char elements[10][10];
}stack;

 

void initialize(stack *sp)
{
    sp->top=-1;
}

 

//FOR ADDING VALUES TO IT
void push(stack *sp,char* item)
{
    if(sp->top == SIZE-1)
    printf("\nstack overflow\n");
    else
    strcpy(sp->elements[++sp->top],item);   
    
}

 

//OVERWRITTING
int pop(stack *sp)
{
    int x;             //BECAUSE WE WANT TO RETURN BACK THE VALUE  
    if(sp->top == -1)
    printf("\nstack underflow");
    else
    x=sp->elements[sp->top--];
    return x;
}

 

void display(stack *sp)
{
    int i;
    
    for(i=sp->top;i!=-1;i--)
    {
        printf("%s\n",*(sp->elements+i));
    }
}
int main()
{
    stack e1;
    
    initialize(&e1);
    push(&e1,"VISHAL");
    push(&e1,"HEMANT");
    push(&e1,"JOSEPHINE");
    push(&e1,"ABHISHEK");
    push(&e1,"NILESH");
    
    display(&e1);
    
    printf("\n\n");
    pop(&e1);
    
    display(&e1);
}
========================================================================================================================

Q.8 Create two stacks A and B . A contains 3 alphabets and B contains 3 numbers. Display Both stacks.

Ans. #include<stdio.h>
     #include<stdlib.h>
#define SIZE 3

typedef struct a_st
{
	int Atop;
	char Aelements[SIZE];
}A;

typedef struct b_st
{
	int Btop;
	int Belements[SIZE];
}B;

void Ainitialize(A *sp)
{
	sp->Atop=-1;
}

void Binitialize(B *sp)
{
	sp->Btop=-1;
}

void Apush(A *sp,char item)
{
	if(A_is_full(sp))
	printf("\nstack overflow\n");
	
	else
	sp->Aelements[++sp->Atop]=item;
}

void Bpush(B *sp,int item)
{
	if(B_is_full(sp))
	printf("\nstack overflow\n");
	
	else
	sp->Belements[++sp->Btop]=item;
}

int Apop(A *sp)
{
	int x;
	
	if(A_is_empty(sp))
	printf("\nstack underflow");
	
	else
	x=sp->Aelements[sp->Atop--];
	
	return x;
}

int Bpop(B *sp)
{
	int x;
	
	if(B_is_empty(sp))
	printf("\nstack underflow");
	
	else
	x=sp->Belements[sp->Btop--];
	
	return x;
}

int A_is_full(A*sp)
{
	if(sp->Atop == SIZE-1)
	return 1;
	
	else
	return 0;
}

int B_is_full(B *sp)
{
	if(sp->Btop == SIZE-1)
	return 1;
	
	else
	return 0;
}

int A_is_empty(A *sp)
{
	if(sp->Atop == -1)
	return 1;
	
	else
	return 0;
}

int B_is_empty(B *sp)
{
	if(sp->Btop == -1)
	return 1;
	
	else
	return 0;
}

void A_display(A *sp)
{
	int i;
	
	for(i=sp->Atop;i!=-1;i--)
	{
		printf("%c",sp->Aelements[i]);
	}
	
	printf("\n\n");
}

void B_display(B *sp)
{
	int i;
	
	for(i=sp->Btop;i!=-1;i--)
	{
		printf("%d",sp->Belements[i]);
	}
	
	printf("\n\n");
}

int main()
{
	 A a;
	
	Ainitialize(&a);
	
	Apush(&a,'a');
	Apush(&a,'b');
	Apush(&a,'c');
	
	A_display(&a);
	
	B b;
	
	Binitialize(&b);
	
	Bpush(&b,1);
	Bpush(&b,2);
	Bpush(&b,3);
	
	B_display(&b);
	
	
}
===========================================================================================================================================

Q.9 Create a queue which contains 5 double values and print all values.

Ans. #include<stdio.h>
#define SIZE 7

typedef struct queue
{
	int front;
	int rear;
	double elements[SIZE];
}queue;

void initialize(queue *qp)
{
	qp->front=-1;
	qp->rear=-1;
}

void add(queue *qp,double item)
{
	if(qp->rear=-SIZE-1)
	printf("\nqueue overflow");
	
	else
	qp->elements[++qp->rear]=item;
}

int rem(queue *qp)
{
	double x;
	if(qp->front==-1)
	printf("\nqueue is empty");
	
	else
	x=qp->elements[qp->front++];
	return x;
}

void display(queue *qp)
{
	int i;
	for(i=qp->front;i<qp->rear;i++)
	{
		printf("lf\t",qp->elements[i]);
	}
	
}

int main()
{
	queue q;
	initialize(&q);
	add(&q,1.4444);
	add(&q,5.888);
	add(&q,77.66);
	add(&q,70);
	add(&q,8.9);
	
	display(&q);
}
===================================================================================================================================

Q.10 Create a queue which contains 5 numbers and print the square value of every element of the queue.

Ans. #include<stdio.h>
#define SIZE 7

typedef struct queue
{
	int front;
	int rear;
	int elements[SIZE];
}queue;

void initialize(queue *sp)
{
	sp->front=-1;
	sp->rear=-1;
}

void add(queue *sp,int item)
{
	if(sp->rear==SIZE-1)
	printf("\nstack overflow");
	
	else
	{
		if(sp->front==-1)
		sp->front=0;
		sp->elements[++sp->rear]=item;
    }

}

int rem(queue *sp)
{
	char x;
	if(sp->front==-1)
	printf("\nstack underflow");
	
	else
	x=sp->elements[sp->front++];
	
	return x;
}

void display(queue *sp)
{
	int i;
	for(i=sp->front;i<=sp->rear;i++)
	{
		printf("square values is : %d\n",(sp->elements[i])*(sp->elements[i]));
	}
}

int main()
{
	queue v;
	initialize(&v);
	add(&v,1);
	add(&v,2);
	add(&v,3);
	add(&v,4);
	add(&v,5);

    display(&v);	
}
============================================================================================================================================

Q.11 Create a stack which contains ASCII values for alphabets and print Alphabets.

Ans. #include<stdio.h>
     #include<stdlib.h>
#define SIZE 27

typedef struct st
{
	int top;
	int elements[SIZE];
}stack;

void initialize(stack *sp)
{
	sp->top=-1;
}

void push(stack *sp,int item)
{
	if(is_full(sp))
	printf("\nstack overflow");
	
	else
	sp->elements[++sp->top]=item;
}

int pop(stack *sp)
{
	int x;
	
	if(is_empty(sp))
	printf("\nstack underflow");
	
	else
	x=sp->elements[sp->top--];
	
	return x;
	
}

int is_full(stack *sp)
{
	if(sp->top==SIZE-1)
	return 1;
	
	else
	return 0;
}

int is_empty(stack *sp)
{
	if(sp->top==-1)
	return 1;
	
	else
	return 0;
}

void display(stack *sp)
{
	int v;
	
	for(v=sp->top;v!=-1;v--)
	{
		printf("%c\t",sp->elements[v]);
	}
}

int main()
{
	stack v1;
	
	initialize(&v1);
	
	int v;
	
	for(v=70;v<90;v++)
	{
		push(&v1,v);
	}
	
	display(&v1);
}
=================================================================================================================================

Q.12 Take 10 numbers from user, Make two stacks as Even & Odd, Even stack contains even numbers , Odd stack contains odd numbers.

Ans. #include<stdio.h>
     #include<stdlib.h>
#define SIZE 20

 

typedef struct Odd_st
{
    int Atop;
    int Aelements[SIZE];    
}odd;
typedef struct Even_st
{
    int Btop;
    int Belements[SIZE];    
}even;

 


void Ainitialize(odd *sp)
{
    sp->Atop=-1;
}
void Binitialize(even *sp)
{
    sp->Btop=-1;
}

 

void Apush(odd *sp,char item)
{
        if(A_is_full(sp))    
            printf("\nStack overflow\n");
        else
            sp->Aelements[++sp->Atop]=item;
}
void Bpush(even *sp,int item)
{
        if(B_is_full(sp))    
            printf("\nStack overflow\n");
        else
            sp->Belements[++sp->Btop]=item;
}

 

int Apop(odd *sp)
{
    int x;
    if(A_is_empty(sp))
        printf("\nStack underflow");
    else
        x=sp->Aelements[sp->Atop--];
    return x;    
}
int Bpop(even *sp)
{
    int x;
    if(B_is_empty(sp))
        printf("\nStack underflow");
    else
        x=sp->Belements[sp->Btop--];
    return x;    
}

 

int A_is_full(odd*sp)   
{
    if(sp->Atop == SIZE-1)      
        return 1;
    else
        return 0;
}
int B_is_full(even *sp)   
{
    if(sp->Btop == SIZE-1)      
        return 1;
    else
        return 0;
}

 

int A_is_empty(odd *sp)   
{
    if(sp->Atop == -1)          
        return 1;
    else
        return 0;    
}
int B_is_empty(even *sp)   
{
    if(sp->Btop == -1)          
        return 1;
    else
        return 0;    
}
void A_display(odd *sp)
{
    int i;
    
    for(i=sp->Atop;i!=-1;i--)
    {
        printf("%d ",sp->Aelements[i]);    
    }    
    printf("\n");
}

 

void B_display(even *sp)
{
    int i;
    
    for(i=sp->Btop;i!=-1;i--)
    {
        printf("%d ",sp->Belements[i]);    
    }    
    printf("\n");
}

 

int main()
{
    odd a;
    even b;
    int *s;
    Ainitialize(&a);
    Binitialize(&b);
    int i,v;
    for(i=0;i<10;i++)
    {
        printf("Enter Number :");
        scanf("%d",&v);
        {
          int val=v%2;
              switch(val)
         {
           case 0:
                Apush(&a,v);
                break;
           case 1:
                Bpush(&b,v);
                break;
         }
        }
    }
    A_display(&a);
    B_display(&b);
    
    
}
===========================================================================================================================================

Q.13 Make a program to copy elements of one stack to another.

Ans. #include<stdio.h>
     #include<stdlib.h>
#include<string.h>
#define SIZE 10

typedef struct a_st
{
	int Atop;
	char Aelements[SIZE];
}A;

typedef struct b_st
{
	int Btop;
	char Belements[SIZE];
}B;

void Ainitialize(A *sp)
{
	sp->Atop=-1;
}

void Binitialize(B *sp)
{
	sp->Btop=-1;
}

void A_push(A *sp,char item)
{
	if(A_is_full(sp))
	printf("\nstack overflow");
	
	else
	sp->Aelements[++sp->Atop]=item;
}

void Bpush(B *sp,char item)
{
	if(B_is_full(sp))
	printf("\nstack overflow");
	
	else
	sp->Belements[++sp->Btop]=item;
}

int Apop(A *sp)
{
	int x;
	
	if(A_is_empty(sp))
	printf("\nstack underflow");
	
	else
	x=sp->Aelements[sp->Atop--];
	
	return x;
}

int A_is_full(A*sp)
{
	if(sp->Atop == SIZE-1)
	return 1;
	
	else
	return 0;
}

int B_is_full(B*sp)
{
	if(sp->Btop == SIZE-1)
	return 1;
	
	else
	return 0;
}

int A_is_empty(A *sp)
{
	if(sp->Atop == -1)
	return 1;
	
	else
	return 0;
}

int B_is_empty(B *sp)
{
	if(sp->Btop == -1)
	return 1;
	
	else
	return 0;
}

void A_display(A *sp)
{
	int i;
	
	for(i=sp->Atop;i!=-1;i--)
	{
		printf("%d",sp->Aelements[i]);
	}
	
	printf("\n\n");
}

void B_display(B *sp)
{
	int i;
	
	for(i=sp->Btop;i!=-1;i--)
	{
		printf("%d",sp->Belements[i]);
	}
	
	printf("\n\n");
}

int main()
{
	A a;
	Ainitialize(&a);
	
	B b;
	Binitialize(&b);
	
	int *p1;
	
	p1=&a;
	
	int i,j;
	
	for(i=0;i<SIZE;i++)
	{
		printf("enter the number : ");
		scanf("%d",&j);
		
		Apush(&a,j);
		Bpush(&b,j);
	}
	
	A_display(&a);
	printf("\n");
	
	B_display(&b);
	
}
============================================================================================================================

Q.14 Read 5 numbers from user and store it in a stack.

Ans. #include<stdio.h>
     #include<stdlib.h>
#define SIZE 7

typedef struct st
{
	int top;
	int elements[SIZE];
}stack;

void initialize(stack *sp)
{
	sp->top=-1;
}

void push(stack *sp,int item)
{
	if(is_full(sp))
	printf("\nstack overflow");
	
	else
	sp->elements[++sp->top]=item;
}

int pop(stack *sp)
{
	int x;
	
	if(is_empty(sp))
	printf("\nstack underflow");
	
	else
	x=sp->elements[sp->top--];
	
	return x;
}

int is_full(stack *sp)
{
	if(sp->top==SIZE-1)
	return 1;
	
	else
	return 0;
}

int is_empty(stack *sp)
{
	if(sp->top==-1)
	return 1;
	
	else
	return 0;
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i++)
	{
		printf("%d",sp->elements[i]);
	}
	
	printf("\n");
}

int main()
{
	stack s1;
	initialize(&s1);
	
	int i,j;
	for(i=s1.top;i<4;i++)
	{
		printf("enter the number : ");
		scanf("%d",&j);
		push(&s1,j);
	}
	
	display(&s1);
	
}
============================================================================================================================

Q.15 Create a Link list of 5 nodes which stores information as a character.

Ans. #include<stdio.h>
     #include<stdlib.h>

 

typedef struct nd             
{                           
    char data;
    struct nd *next;
}node;

 

typedef struct ls
{
    node *head,*tail;
}list;

 

node* createNode(char no)
{
    node *np;
    
    np=(node*)malloc(sizeof(node));  
    
    if(np == NULL)
    {
        printf("Memory not available");
        exit(0);    
    }
    
    np->data=no;
    np->next=NULL;
    
    return np;
}

 

void initalize(list *p)
{
    p->head = NULL;
    p->tail = NULL;
}
void insertAtail(list *p,char x)
{
    node *np;
    np = createNode(x);
    if(p->head==NULL)
    p->head = np;
    else
    p->tail->next = np;
    p->tail = np;
}

 

void traverse(list *p)
{
    node *sp;
    sp = p->head;
    
    while(sp!=NULL)
    {
        printf("%c",sp->data);
        sp=sp->next;
    }
}
int main()
{    
    list *p;
    
    p = (list*) malloc(sizeof(list));
    
    if(p == NULL)
    {
        printf("MEMORY UNVAVAILABLE");
        exit(0);
    }
    
    initalize(p);
    insertAtail(p,'A');
    insertAtail(p,'B');
    insertAtail(p,'C');
    insertAtail(p,'D');
    insertAtail(p,'E');
    
    traverse(p);
    
    free(p);
}
=======================================================================================================================================

Q.16 Write a program to count the number of nodes in the link list.

Ans. #include<stdio.h>
     #include<conio.h>

typedef struct list
{
	int data;
	struct list *next;
}node;

node *start=NULL;
node *creat(node*);
node *display(node*);
int countnode(node*);

void main()
{
	int option,c=0;
	
	do
	{
		printf("\n main menu");
		printf("\n1:create list");
		printf("\n2:display list");
		printf("\n3:count node");
		printf("\n0:exit\n");
		printf("\nenter option:");
		scanf("%d",&option);
		switch(option)
		{
			case 1:start=creat(start);
			printf("\nlinked list created");
			break;
			case 2:start=display(start);
			break;
			case 3:c=countnode(start);
			printf("\nthese are %d node in list\n",c);
			break;
			case 0:
			exit(0);
		}
		
     }
     
     while(option!=0);
     getch();
}

node *creat(node *start)
{
	node *ptr,*newnode;
	int num;
	printf("enter data,press 999 to exit:");
	scanf("%d",&num);
	while(num!=999)
	{
		newnode=(node*)malloc(sizeof(node));
		newnode->data=num;
		if(start==NULL)
		{
			newnode->next=NULL;
			start=newnode;
		}
		else
		{
			ptr=start;
			while(ptr->next!=NULL)
			ptr=ptr->next;
			ptr->next=newnode;
			newnode->next=NULL;
		}
		
		printf("enter another data : ");
		scanf("%d",&num);
	}
	
	return start;
}

node* display(node* start)
{
	node *ptr;
	ptr=start;
	while(ptr!=NULL)
	{
		printf("\%d->",ptr->data);
		ptr=ptr->next;
	}
	return start;
}

int countnode(node* start)
{
	node *ptr;
	int x=0;
	ptr=start;
	while(ptr!=NULL)
	{
		x++;
		ptr=ptr->next;
	}
	return x;
}
======================================================================================================================================

Q.17 Create a Link list of 3 nodes containing 3 double values and print the average of 3 numbers.

Ans. #include<stdio.h>
     #include<stdlib.h>
     
typedef struct nd             

{                           

    double data;

    struct nd *next;

}node;

 

typedef struct ls

{

 node *head,*tail;

}list;

 

node* createNode(double no)

{

    node *np;

    

    np=(node*)malloc(sizeof(node));  

    

    if(np == NULL)

    {

        printf("Memory not available");

        exit(0);    

    }

    

    np->data=no;

    np->next=NULL;

    

    return np;

}

 

void initalize(list *p)

{

 p->head = NULL;

 p->tail = NULL;

}

void insertAtail(list *p,double x)

{

 node *np;

 np = createNode(x);

 if(p->head==NULL)

 p->head = np;

 else

 p->tail->next = np;

 p->tail = np;

}

 

void traverse(list *p)

{

    node *sp;

    sp = p->head;

    

    while(sp!=NULL)

    {

     printf("%lf\n",sp->data);

     sp=sp->next; 

     

     printf("\n");

 }

 sp=p->head;

 float sum=0;

 while(sp!=NULL)

 {

 sum=(sum+sp->data);

 sp=sp->next;

 }

 printf("\nSUM = %f",sum);

 float avg=0;

 avg=sum/3;

 printf("\nAVERAGE = %f",avg);

}

 

int main()

{    

    list *p;

    

    p = (list*) malloc(sizeof(list));

    

    if(p == NULL)

    {

     printf("MEMORY UNVAVAILABLE");

     exit(0);

 }

 

 initalize(p);

 insertAtail(p,12.357);

 insertAtail(p,14.2345);

 insertAtail(p,17.234);

 

 traverse(p);

 

 free(p);

    

}
===========================================================================================================================================

Q.18 Create a Link list of 5 nodes and print it in reverse order.

Ans. #include<stdio.h>
     #include<stdlib.h>

struct node
{
	int data;
	struct node*nextptr;
};

struct node*startnode;


void createnodelist(int numberofnodes);

void reversenodelist();

void displaynodelist();

int main()
{
	int numberofnodes;
	
	printf("input the number of nodes : ");
	scanf("%d",&numberofnodes);
	
	createnodelist(numberofnodes);
	
	printf("\ndata entered in the list are : \n");
	displaynodelist();
	
	printf("\nthe list in reverse are : \n");
	reversenodelist();
	displaynodelist();
	return 0;
}

void createnodelist(int numberofnodes)
{
	struct node*newnode;
	struct node*tempnode;
	int userinput;
	int nodeid;
	
	startnode = (struct node *)malloc(sizeof(struct node));
	
	if(startnode == NULL)
	{
		printf("memory can not be allocated");
	}
	
	else
	{
		printf("input data for user 1 : ");
		scanf("%d", &userinput);
		
		startnode->data = userinput;
		startnode->nextptr = NULL;
		
		tempnode = startnode;
		
		for(nodeid = 2; nodeid <= numberofnodes; nodeid++)
		{
			newnode = (struct node *)malloc(sizeof(struct node));
			
			if(newnode == NULL)
			{
				printf("memory can not be allocated. ");
				break;
			}
			else
			{
				printf("input data for node %d : ", nodeid);
				scanf("%d",&userinput);
				
				newnode->data = userinput;
				newnode->nextptr = NULL;
				
				tempnode->nextptr = newnode;
				tempnode = tempnode->nextptr;
			}
		}
	}
	 
}
void reversenodelist()
{
	struct node *previousnode;
	struct node *currentnode;
	
	if(startnode != NULL)
	{
		previousnode = startnode;
		
		currentnode = startnode->nextptr;
		startnode = startnode->nextptr;
		
		previousnode->nextptr = NULL;
		
		while(startnode != NULL)
		{
			startnode = startnode->nextptr;
			currentnode->nextptr = previousnode;
			
			previousnode = currentnode;
			currentnode = startnode;
		}
		
		startnode = previousnode;
	}
}

void displaynodelist()
{
	struct node *tempnode;
	
	if(startnode == NULL)
	{
		printf("no data found in the list.");
	}
	else
	{
		tempnode = startnode;
		
		while(tempnode != NULL)
		{
			printf("data = %d\n", tempnode->data);
			tempnode = tempnode->nextptr;
		}
	}
}
=====================================================================================================================================

Q.19 Create a Link list of 3 nodes and delete the head node.

Ans. #include<stdio.h>
     #include<stdlib.h>

struct node
{
	int data;
	struct node *nextptr;
};

struct node *firstnode;

void createnodelist(int numberofnodes);

void deletefirstnode();

void displaynodelist();

int main()
{
	int numberofnodes;
	
	printf("input the number of nodes : ");
	scanf("%d", &numberofnodes);
	
	createnodelist(numberofnodes);
	
	printf("\ndata entered in the list are : \n");
	displaynodelist();
	
	deletefirstnode();
	
	printf("\ndata after deletion of first node : \n");
	displaynodelist();
	return 0;
}

void createnodelist(int numberofnodes)
{
struct node *newnode;
struct node *tempnode;
int nodedata;
int nodectr;

firstnode = (struct node *)malloc(sizeof(struct node));

if(firstnode == NULL)
{
	printf("memory can not be allocated.");
}
else
{
	printf("input data for node 1 :");
	scanf("%d",&nodedata);
	
	firstnode->data = nodedata;
	firstnode->nextptr = NULL;
	
	tempnode = firstnode;
	
	for(nodectr =2; nodectr <= numberofnodes; nodectr++)
	{
		newnode = (struct node *)malloc(sizeof(struct node));
		
		if(newnode == NULL)
		{
			printf("memory can not be allocated.");
			break;
		}
		else 
		{
			printf("input data for node %d : ", nodectr);
			scanf("%d", &nodedata);
			
			newnode->data = nodedata;
			newnode->nextptr = NULL;
			
			tempnode->nextptr = newnode;
			tempnode = tempnode->nextptr;
		}
	}
}
	
}
void deletefirstnode()
{
	struct node *tempptr;
	
	if(firstnode == NULL)
	{
		printf("there are no node in the list.");
	}
	else
	{
		tempptr = firstnode;
		
		firstnode = firstnode->nextptr;
		
		printf("\ndata of node 1 which is being deleted is : %d\n", tempptr);
		
		free(tempptr);
	}
}

void displaynodelist()
{
	struct node *tempptr;
	
	if(firstnode == NULL)
	{
		printf("no data found in the list.");
	}
	else
	
	tempptr = firstnode;
	while(tempptr !=NULL)
	{
		printf("data = %d\n", tempptr->data);
		
		tempptr = tempptr->nextptr;
	}
}
==========================================================================================================================================

Q.20 Create a list of 3 city names and Enter a city to be searched in the list .If city name exists in list then Display City Found.

Ans. #include<stdio.h>
     #include<string.h>

int main()
{
	char str[20][50], s1[50];
	int n,i,found=0;
	
    printf("ENTER HOW MANY CITIES YOU WANT TO ENTER : ");
	scanf("%d",&n);
	
	printf("ENTER %d CITY NAMES :\n",n);
	
	for(i=0;i<n;i++)
	{
		scanf("%s",str[i]);
	}
	
	printf("ENTER CITY NAME TO SEARCH :  ");
	scanf("%s",s1);
	
	for(i=0;i<n;i++)
	{
		if(strcmp(s1,str[i])==0)
		{
			found = 1;
			printf("FOUND %d\n",i+1);
		}
	}
	
	
	if(found==0)
	printf("NOT FOUND");
	
	return 0;
}
============================================================================================================================================

Q.21 Create an array of 5 integer values and search an element in the array using Linear Search.

Ans. #include<stdio.h>
     #include<conio.h>

void main()
{
	int a[50],n,i,j,v=0;
	
	printf("enter the number of elements to store:\n");
	scanf("%d",&n);
	
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
	}
	printf("enter the element to search :\n");
	scanf("%d",&j);
	
	for(i=0;i<n;i++)
	{
		if(a[i]==j)
		{
			printf("element found :");
			v=1;
			break;
		}
	}
	
	if(v==0)
	printf("element not found :");
	getch();
}
========================================================================================================================

Q.22 Create an array of string and search a particular string using Linear Search.

Ans. #include<stdio.h>
     #include<string.h>

void main()
{
	char name[5][10], s[10];
	int i;
	for(i=0; i<5; i++)
	{
		printf("enter name : ");
		gets(name[i]);
	}
	
	printf("enter name to search : ");
	gets(s);
	
	for(i=0;i<5;i++)
	{
		if(strcmpi(s,name[i])==0)
		{
			printf("found");
			break;
		}
		
		else(i==5);
		
	    printf("not found");
	    break;
    }
	
}
=====================================================================================================================================

Q.23 Sort an array of 5 numbers using Insertion sort

Ans. #include<stdio.h>
     #include<conio.h>

void main()
{
	int n, array[1000], c, d, t;
	
	printf("enter number of elements\n");
	scanf("%d",&n);
	
	printf("enter %d integers\n", n);
	
	for(c=0; c < n; c++)
	{
		scanf("%d", &array[c]);
	}
	
	for(c = 1; c <= n-1; c++)
	{
		d = c;
		
		while (d > 0 && array[d] < array[d-1])
		{
			t=array[d];
			array[d]=array[d-1];
			array[d-1]=t;
			
			d--;
		}
	}
	
	printf("sorted list in accending order :\n");
	
	for(c=0;c<=n-1;c++)
	{
		printf("%d\n",array[c]);
	}
	getch();
}
==========================================================================================================================

Q.24 Make a tree which contains 3 nodes. A is Root node, B is left child and C is right child.

Ans. #include<stdio.h>

typedef struct tr
{
	int data;
	struct tr *left;
	struct tr *right;
}tree;

 tree* createnode(int value)
{
	 tree *n;
	n=( tree*)malloc(sizeof( tree));
	
	n->data=value;
	n->left=NULL;
	n->right=NULL;
	
	return n;
}

int main()
{
	 tree *root,*n1,*n2;
	
	root=createnode(100);
	
	n1=createnode(200);
	
	n2=createnode(300);
	
	root->left=n1;
	root->right=n2;
	
	printf("\t%d\n",root->data);
	printf("%d\t",root->left->data);
	printf("\t%d",root->right->data);
	
	
}
=========================================================================================================================================

Q.25 Create a tree of 3 nodes where root node displays the value as "Color" , Left node of root shows value as "Red" and right node shows value as Green. 
     and print all node values in using preorder traversal.
     
Ans. #include<stdio.h>
     #include<stdlib.h>
     #include<string.h>

 

typedef struct nd
{
    char data[3][10];
    struct nd *left;
    struct nd *right;
}tree;

 

tree* createnode(char* no)
{
    tree *np;
    
    np = (tree*)malloc(sizeof(tree));
    
    if(np == NULL)
    {
        printf("MEMORY UNAVAILABLE");
        exit(0);
    }
    
    strcpy(np->data,no);
    np->left = NULL;
    np->right = NULL;
    
    return np;
}

 

void preorderTraversal(tree* root)
{
    if(root == NULL)
    return;
    printf("%s->",root->data);
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}

 

int main()
{
    tree *root,*n,*m;
    
    root = createnode("COLOUR");
    n = createnode("RED");
    m = createnode("GREEN");

 

    root->left = n;
    root->right = m;
    
    printf("ROOT NODE = %s\n",root->data);
    printf("LEFT NODE = %s\n",root->left->data);
    printf("RIGHT NODE = %s\n",root->right->data);

 

    printf("\n");
    
    preorderTraversal(root);

 

}
========================================================================================================================================

Q.27 Write a program to crate an adjacency matrix(3 by 3) using graph , where create edges (0,1),(1,2),(1,1), Store the student age information.

Ans. #include<stdio.h>

int main()
{
	int ad[3][3];
	
	int age;
	
	int i, j;
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			if(i==0 && j==1)
			{
				printf("enter age : ");
				scanf("%d", &age);
				ad[i][j]=age;
			}
			
			else if(i==1 && j==1)
			{
				printf("enter age : ");
				scanf("%d", &age);
				ad[i][j]=age;
			}
			
			else if(i==1 && j==2)
			{
				printf("enter age : ");
				scanf("%d", &age);
				ad[i][j]=age;
			}
			
			else
			{
				ad[i][j]=0;
			}
			
		}
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			printf("%d\t",ad[i][j]);
		}
		
		printf("\n");
	}
}
===========================================================================================================================================


